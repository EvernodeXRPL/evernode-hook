"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const xrp_codec_1 = require("./xrp-codec");
Object.defineProperty(exports, "codec", { enumerable: true, get: function () { return xrp_codec_1.codec; } });
Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } });
Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } });
Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } });
Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } });
Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } });
Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } });
Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } });
Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } });
Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } });
const assert = require("assert");
const PREFIX_BYTES = {
    MAIN: Buffer.from([0x05, 0x44]),
    TEST: Buffer.from([0x04, 0x93]) // 4, 147
};
function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = xrp_codec_1.decodeAccountID(classicAddress);
    return encodeXAddress(accountId, tag, test);
}
exports.classicAddressToXAddress = classicAddressToXAddress;
function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) {
        // RIPEMD160 is 160 bits = 20 bytes
        throw new Error('Account ID must be 20 bytes');
    }
    const MAX_32_BIT_UNSIGNED_INT = 4294967295;
    const flag = tag === false ? 0 : tag <= MAX_32_BIT_UNSIGNED_INT ? 1 : 2;
    if (flag === 2) {
        throw new Error('Invalid tag');
    }
    if (tag === false) {
        tag = 0;
    }
    const bytes = Buffer.concat([
        test ? PREFIX_BYTES.TEST : PREFIX_BYTES.MAIN,
        accountId,
        Buffer.from([
            flag,
            tag & 0xff,
            (tag >> 8) & 0xff,
            (tag >> 16) & 0xff,
            (tag >> 24) & 0xff,
            0, 0, 0, 0 // four zero bytes (reserved for 64-bit tags)
        ])
    ]);
    const xAddress = xrp_codec_1.codec.encodeChecked(bytes);
    return xAddress;
}
exports.encodeXAddress = encodeXAddress;
function xAddressToClassicAddress(xAddress) {
    const { accountId, tag, test } = decodeXAddress(xAddress);
    const classicAddress = xrp_codec_1.encodeAccountID(accountId);
    return {
        classicAddress,
        tag,
        test
    };
}
exports.xAddressToClassicAddress = xAddressToClassicAddress;
function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    const test = isBufferForTestAddress(decoded);
    const accountId = decoded.slice(2, 22);
    const tag = tagFromBuffer(decoded);
    return {
        accountId,
        tag,
        test
    };
}
exports.decodeXAddress = decodeXAddress;
function isBufferForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if (PREFIX_BYTES.MAIN.equals(decodedPrefix)) {
        return false;
    }
    else if (PREFIX_BYTES.TEST.equals(decodedPrefix)) {
        return true;
    }
    else {
        throw new Error('Invalid X-address: bad prefix');
    }
}
function tagFromBuffer(buf) {
    const flag = buf[22];
    if (flag >= 2) {
        // No support for 64-bit tags at this time
        throw new Error('Unsupported X-address');
    }
    if (flag === 1) {
        // Little-endian to big-endian
        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;
    }
    assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');
    assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');
    return false;
}
function isValidXAddress(xAddress) {
    try {
        decodeXAddress(xAddress);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidXAddress = isValidXAddress;
//# sourceMappingURL=index.js.map